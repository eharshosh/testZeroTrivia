{"version":3,"file":"pdfExtractor.js","sourceRoot":"","sources":["pdfExtractor.ts"],"names":[],"mappings":";;;;;;;;;;AACA,iCAAiC;AACjC,MAAa,YAAY;IACrB,YAA2B,UAAkB;QAAlB,eAAU,GAAV,UAAU,CAAQ;IAAE,CAAC;IAE1C,gBAAgB;;YAClB,MAAM,EAAC,IAAI,EAAC,GAAG,MAAM,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YAC1C,MAAM,MAAM,GAAsB,EAAE,CAAC;YACrC,IAAI,MAAM,CAAC;YACX,MAAM,GAAG,GAAG,gBAAgB,CAAC;YAC7B,OAAO,CAAC,MAAM,GAAG,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,KAAK,IAAI,EAAE;gBACvC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;aACvB;YACD,MAAM,SAAS,GAAG,EAAE,CAAC;YACrB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;gBACxC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;aACxE;YACD,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YAChE,OAAO,SAAS,CAAC,GAAG,CAAC,YAAY,CAAC,eAAe,CAAC,CAAC;QACvD,CAAC;KAAA;IAEO,MAAM,CAAC,eAAe,CAAC,YAAoB;QAC/C,MAAM,MAAM,GAAG,EAAE,CAAC;QAClB,KAAK,IAAI,IAAI,IAAI,YAAY,CAAC,KAAK,CAAC,IAAI,CAAC,EAAC;YACtC,MAAM,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,CAAC;YAChD,MAAM,oBAAoB,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC;YACpE,IAAI,oBAAoB,EAAE;gBACtB,aAAa,CAAC,CAAC,CAAC,GAAG,GAAG,oBAAoB,CAAC,CAAC,CAAC,KAAK,oBAAoB,CAAC,CAAC,CAAC,EAAE,CAAC;aAC/E;YAED,MAAM,kBAAkB,GAAG,aAAa,CAAC,aAAa,CAAC,MAAM,GAAC,CAAC,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;YACjF,IAAI,kBAAkB,EAAE;gBACpB,IAAI,CAAC,kBAAkB,CAAC,CAAC,CAAC,EAAE;oBACxB,SAAS;iBACZ;gBACD,aAAa,CAAC,aAAa,CAAC,MAAM,GAAC,CAAC,CAAC,GAAG,GAAG,kBAAkB,CAAC,CAAC,CAAC,GAAG,CAAC;aACvE;YAED,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;SACxC;QACD,OAAO,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC7B,CAAC;CACJ;AAxCD,oCAwCC","sourcesContent":["import {ITestTextExtractor} from \"../ITestTextExtractor\";\nimport * as pdf from \"pdf-parse\";\nexport class PdfExtractor implements ITestTextExtractor {\n    public constructor(private fileStream: Buffer){}\n\n    async extractQuestions() : Promise<string[]> {\n        const {text} = await pdf(this.fileStream);\n        const tokens: RegExpExecArray[] = [];\n        let result;\n        const exp = /\\d+ מספר שאלה/g;\n        while ((result = exp.exec(text)) !== null) {\n            tokens.push(result);\n        }\n        const questions = [];\n        for (let i = 0; i < tokens.length - 1; i++) {\n            questions.push(text.substring(tokens[i].index, tokens[i + 1].index));\n        }\n        questions.push(text.substring(tokens[tokens.length - 1].index));\n        return questions.map(PdfExtractor.fixRtlWordOrder);\n    }\n\n    private static fixRtlWordOrder(questionText: string) : string {\n        const result = [];\n        for (let line of questionText.split('\\n')){\n            const reversedWords = line.split(' ').reverse();\n            const questionOptionsMatch = reversedWords[0].match(/^(.*)\\.(\\d)$/);\n            if (questionOptionsMatch) {\n                reversedWords[0] = `${questionOptionsMatch[2]}. ${questionOptionsMatch[1]}`;\n            }\n\n            const questionTitleMatch = reversedWords[reversedWords.length-1].match(/:(.*)$/);\n            if (questionTitleMatch) {\n                if (!questionTitleMatch[1]) {\n                    continue;\n                }\n                reversedWords[reversedWords.length-1] = `${questionTitleMatch[1]}:`;\n            }\n\n            result.push(reversedWords.join(' '));\n        }\n        return result.join('\\n');\n    }\n}\n"]}